# 从零搭建个人博客系统

​	之前的博客使用hexo搭建，使用了next主题，整个博客几乎零基础，感兴趣的可以参考[这篇文章](http://gatinul.org/more/hexo-github)。由于实践是提升技术的最好方式，一直想做个个人网站，然后在过程中学习更多。最后选择重建自己的个人博客，由于意在学习，所以网站用到的技术会比较杂，本文也只是个概述，具体请点进去具体文章查看。

> 1. 博客首页：[地址](http://gatinul.org)
> 2. 发布博客：[地址](http:gatinul.org:8080)

 

## 发布博客

- 页面主要使用antd展示，使用react编写
- 路由来回选择半天，最终使用了react-router@3（详情：[react路由折腾](http://gatinul.org/more/react路由折腾)）
- 服务端方面使用koa@2，async／await的编写方式（详情：[Koa2文件上传](http://gatinul.org/more/Koa2文件上传)）
- 数据库操作使用mysql（详情：[node+msyql的优雅使用](http://gatinul.org/more/node+mysql的优雅使用)）
- 网络优化（详情：[nginx转发node应用](http://gatinul.org/more/nginx转发node应用)）
- 其他工具的使用（详情：[webpack基本配置](http://gatinul.org/more/webpack基本配置)，[travis自动化构建](http://gatinul.org/more//travis自动化构建)）

### 登录页面

由于使用了antd，直接搬运form组件，然后自己进行修改。这里异步操作使用了axios，不过自己又简单封装了下，核心代码如下（详情：[axios进行异步操作](http://gatinul.org/more/axios进行异步操作)）：

``` javascript
// api/index.js
export function fetch(url, params) {
  return new Promise((resolve, reject) => {
    axios
      .post(url, params)
      .then(res => {
        resolve(res.data);
      })
      .catch(err => {
        reject(err);
      });
  });
}
```



校验逻辑的话，还是采用了分层的写法。controller：主要解析前端传来的数据，返回处理后的结果，至于如何处理一般写在service层中；service：主要编写业务层逻辑，对controller传过来的数据进行逻辑处理，如果有需与数据库交互的则不是它的责任了，他要反馈给model层处理；model层：接收传来的值，进行数据库操作，返回，就是这么简单，我这里对mysql操作也进行了一个简单的处理（详情：[node+msyql的优雅使用](http://gatinul.org/more/node+mysql的优雅使用)）。

```javascript
const pool = mysql.createPool({
    host: config.HOST,
    user: config.USERNAME,
    password: config.PASSWORD,
    database: config.DATABASE
})

let query = function(sql, values) {

    return new Promise((resolve, reject) => {
        pool.getConnection(function(err, connection) {
            if (err) {
                resolve(err)
            } else {
                connection.query(sql, values, (err, rows) => {

                    if (err) {
                        reject(err)
                    } else {
                        resolve(rows)
                    }
                    connection.release()
                })
            }
        })
    })

}
```

这样使用的时候就可以在model层直接拼好sql语句传过来，像这样

``` javascript
// model/mainModel.js
/**
 * 检查是否已存在
 * @param {object} options 
 */
async isExist(options) {
  let _sql = `
SELECT * FROM user 
WHERE email="${options.email}" or name="${options.name}"`
  let result = await db.query(_sql)
  if (Array.isArray(result) && result.length > 0) {
    result = result[0]
  } else {
    result = null
  }
  return result
},
```

登录页面的主要逻辑，即先在前端界面进行提交表单校验，这里可以使用antd提供的自定义检验定义规则，如果校验成功则发接口到controller层，服务端则判断登录名是否存在，密码和登录名是否对应即可。登录成功后，登录信息将存储在localStorage中，在发布博客中使用。

### 注册页面

因为要做一个类似投稿的功能，不止作者本人能发布博客，其余人也可发布，但是不会立即展示，而是到审核区，审核通过后展示在页面中，所以这里要有个注册功能。注册页面展示一样使用antd组件，校验逻辑写在service中，校验数据的正确性，如邮箱格式等，校验用户是否已存在，如果注册通过，使用react-router的browserHistory跳转路由即可。

### 博客编写页

博客编写页采取markdown预览式编写，其实实现非常简单，左侧是一个美化后的 `textarea`  ，右侧是一个空div，当左侧内容变化时，使用marked.js和highlight.js转换成markdow的格式展现在右侧。（详情：[react的markdown实时预览](http://gatinul.org/more/react的markdown实时预览)）

### 博客发布

博客发布主要实现难点在于文件上传以及监听文件上传的状态，这里在service中写一个异步函数然后用event的on监听返回文件上传结果。核心代码如下（详情：[Koa2文件上传](http://gatinul.org/more/Koa2文件上传)）：

``` javascript
uploadFiles(file,newPath){
      return new Promise(function (resolve, reject) {
        const reader = fs.createReadStream(file.path);
        const stream = fs.createWriteStream(path.join(__dirname, newPath, file.name));
        reader.on('error',(error)=>{
          console.log('service:fail')
          return resolve({
            success:false,
            message:'上传失败，读取文件失败',
            error:error
          })
        }).pipe(stream).on('error',(error)=>{
          console.log('service:fail')
          return resolve({
            success:false,
            message:'上传失败，写入文件失败',
            error:error
          })
        }).on('close',()=>{
          console.log('service:success')
          return resolve({
            success:true,
            message:'上传成功'
          })
        })
      });
    },
```



---



## 博客首页

- 前端使用typescript&rxjs编写（详情：[rxjs编写博客首页](http://gatinul.org/more/rxjs编写博客首页)）
- 服务端直接使用[egg.js](https://eggjs.org/zh-cn)，提供路由，日志，以及数据库插件，模版渲染插件
- 网络优化（详情：[nginx转发node应用](http://gatinul.org/more/nginx转发node应用)）
- 其他工具的使用（详情：[webpack编译typescript](http://gatinul.org/more/webpack编译typescript)，[travis自动化构建](http://gatinul.org/more//travis自动化构建)，[gulp编译typescript](http://gatinul.org/more/gulp编译typescript)）

其中eggjs的使用过程中，遇到了很多问题，也总结了不少，详情：[eggjs的使用](http://gatinul.org/more/eggjs的使用)

### 博客左侧

由于个人比较喜欢简约的风格，网站页面大处留白。左侧为固定部分，展示个人信息和首页、归档等，借(chao)鉴(xi)了尤大的博客首页的canavs画布，对宽带，色彩维度等进行了简单的修改。

- 首页：展示博客文章列表
- 专题：编辑大分类包含小标签（todo）
- 归档：按修改时间轴展示（todo）
- 关于：个人的简介

### 主页

主页展示博客文章列表，使用rxjs控制数据流，核心代码如下：

```javascript
const init = Rx.Observable.create(observer => {
  api.getBlogList(obj).then(res => {
    observer.next(res)
    observer.complete()
  }).catch(err=>{
    observer.error(err)
  })
})
const init$ = init
  .do(res=>{
    totalPage = res.totalPage;    
    blogList.push(res.list);
    showList(blogList[0],currentPage)
  })
```

上面代码首先创建了一个observer进行了一个异步请求，返回成功结果后，observer.next(res)向下传递数据。而一切副作用操作都放在.do中进行，所以下面的.do主要处理将数据展现在界面上。再配合其他的操作一起发布大概是这样

```javascript
const app$ = init$.merge(past$, future$)
  .mergeMap(() => {
    return Rx.Observable.fromEvent($('.more'), 'click')
      .do((e)=>{
        const target = $(e.currentTarget)
        console.log(target.text(), path)
        location.href=(path + 'more/' + target.text())
      })
  })

app$.subscribe()
```

因为下面执行的.more点击事件是绑定在动态渲染出元素，要在init$,past$,future$执行之后，所以这里使用mergeMap()也方便之后再继续应用数据。具体请看（详情：[rxjs编写博客首页](http://gatinul.org/more/rxjs编写博客首页)）

###  文章页

文章页目前没有评论功能，实现十分简单，读取指定的md文件然后通过marked解析后返回，marked配置如下（详情：[编写markdown格式页面](http://gatinul.org/more/编写markdown格式页面)）：

```javascript
marked.setOptions({
  renderer: new marked.Renderer(),
  gfm: true,
  tables: true,
  breaks: true,
  pedantic: false,
  sanitize: true,
  smartLists: true,
  smartypants: false,
  highlight: code => {
    return highlight.highlightAuto(code).value;
  },
});
```

## TODO

1. 博客首页加入搜索功能／elasticsearch

2. 文章页评论功能／不展示在底部，点击才展现／第三方登录

3. 博客左侧显示上传率 每月一组 日历形式

4. 文章访问率

5. 专题／归档

   ​